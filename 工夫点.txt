工夫点

・ピアソンの積率相関係数を計算する関数を設け、画面表示させた
----- correlationCoefficient -----
Class.0: r=-0.182613
Class.1: r=0.0205726
All data: r=0.794333
↑クラスごとのデータと全データの相関係数を表示した

・分類結果の確信度を計算し、画面表示させた
TestData.0: [-0.962073, -1.49651]
 minIndex: 35, 
Class -> 0, Confidence:100%

※上記のConfidenceが確信度

・kNNのkが任意の自然数に対応するようにした
#define Hyperparameter 1

・ユークリッド距離が短い順にkNNで参照したトレインデータを画面表示させた
TestData.23: [-1.17193, -1.06581]
minIndex: 41, 9, 39, 27, 0, 19, 28, 
Class -> 0, Confidence:100%

TestData.24: [-0.761253, -0.59539]
minIndex: 26, 14, 45, 22, 23, 7, 28, 
Class -> 0, Confidence:100%

TestData.25: [0.426538, 0.40993]
minIndex: 81, 56, 66, 64, 94, 50, 55, 
Class -> 1, Confidence:100%

・クラス分類結果の確信度とクラス分類後の各クラスのテストデータ数を画面表示させた
----- number of data -----
Class.0 data: 25
Class.1 data: 25

・main関数内の処理を関数化し、関数用のファイルを作成した

int main(void){
	/*------ここからデータの読み取り------*/
	VectorArray trainData;
	Vector trainCorrect = read_data("2d2c-train.plot", trainData);
	VectorArray tmp_testData;
	Vector testCorrect = read_dataWithoutLabel("2d2c-test.data", tmp_testData);
	/*------ここまでデータの読み取り------*/

	//追加：kの定義
	int k = Hyperparameter;

	//(読み込んだデータの画面表示)
	printData(trainData, tmp_testData);
	//テストデータの識別結果を保存するための配列
	Vector testLabel(tmp_testData.rows());

	//追加：最小距離対象トレーニングデータ番号保存のための配列
	VectorArray minIndexArray(tmp_testData.rows(), k);
	//追加：最多ラベルの個数を保存するための配列
	Vector maxCount(tmp_testData.rows());

	//追加：k個探す
	for (int i=0; i<tmp_testData.rows(); i++)
		serchK(tmp_testData, trainData, trainCorrect, testLabel, minIndexArray, i, k, maxCount);
	//追加：結果を最後にまとめて表示
	printResult(tmp_testData, trainData, trainCorrect, minIndexArray, testLabel, k, maxCount);

	//記録保存
	recordClassified(tmp_testData, testLabel);

	return 0;
}